{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/expr-eval/dist/index.mjs","webpack:///./src/calculate.js","webpack:///./src/drawing.js","webpack:///./src/eventHandling.js","webpack:///./src/functionParsing.js","webpack:///./src/index.js","webpack:///./src/math.js","webpack:///./src/rendering.js","webpack:///./src/table.js"],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,mBAAmB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,mBAAmB;AACpC;AACA;AACA;AACA,qBAAqB,wBAAwB;AAC7C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,mBAAmB;AACpC;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT,sCAAsC,mFAAmF,EAAE;AAC3H,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,oBAAoB;AAC1F,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK,mCAAmC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,+BAA+B;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,mBAAmB;AACpC;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,uHAAuH,0EAA0E,EAAE,GAAG;AACtM;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ,4BAA4B;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ,4BAA4B;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ,4BAA4B;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kCAAkC,EAAE;;AAEpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB;AACvB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oBAAoB;AACpB;;AAEA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,oBAAoB;AACrC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,UAAU,QAAQ;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEe,oEAAK,EAAC;AACS;;;;;;;;;;;;;AC9yD9B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAqD;AACf;AACC;;AAEvC;AACA;AACA,aAAa,yEAAa;AAC1B,8BAA8B,QAAQ;AACtC;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,cAAc,yEAAa;AAC3B,cAAc,yEAAa;;AAE3B;AACA,iCAAiC,SAAS,oBAAoB,SAAS;AACvE,cAAc,6BAA6B,SAAS;AACpD,KAAK;AACL;AACA;AACA;;AAEA;AACA,2BAA2B,EAAE;AAC7B,2BAA2B,EAAE;AAC7B;AACA;AACA,+BAA+B,cAAc,oBAAoB,cAAc;AAC/E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,yEAAa;AAC1B;AACA,yBAAyB,EAAE;AAC3B;AACA,8BAA8B,cAAc;AAC5C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,oBAAoB;AACrC;AACA;AACA,oBAAoB,kDAAI;AACxB;AACA;AACA,uBAAuB,kDAAI;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,2DAAU,UAAU;AAC5D,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gDAAgD,2DAAU,oBAAoB,IAAI,2DAAU,oBAAoB;AAChH,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEqD;;;;;;;;;;;;;ACzGrD;AAAA;AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEe;;;;;;;;;;;;;ACnCf;AAAA;AAAA;AAAA;AAAA;AAAA;AAA4E;AACvB;AACuB;;AAE5E;AACA;AACA;;AAEA;AACA,aAAa,oDAAM;AACnB;AACA,iCAAiC,oDAAM;AACvC,gCAAgC,oDAAM;AACtC;AACA;;AAEA;AACA;AACA,mBAAmB,kDAAI,QAAQ,kDAAI;AACnC,oBAAoB,kDAAI,QAAQ,kDAAI;AACpC;AACA,OAAO,kDAAI,YAAY,oDAAM;AAC7B,OAAO,kDAAI,YAAY,oDAAM;AAC7B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,4CAA4C,oBAAoB;AAChE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;AAEA;AACA;AACA,iBAAiB,qBAAqB;AACtC;AACA,yEAAyE,aAAa;AACtF;AACA,2BAA2B,kDAAI;AAC/B;AACA,+EAA+E,aAAa;AAC5F,KAAK;AACL,aAAa,kDAAI;AACjB;AACA;AACA,EAAE,4DAAM;AACR;;AAEA;AACA;AACA;AACA,iBAAiB,oBAAoB;AACrC;AACA,iCAAiC,WAAW;AAC5C,iCAAiC,WAAW;AAC5C,KAAK;AACL,oCAAoC,WAAW;AAC/C;AACA;AACA;AACA,IAAI,wEAAkB;AACtB;AACA,6BAA6B,QAAQ;AACrC,6BAA6B,QAAQ;AACrC;;AAEA;AACA;AACA;AACA,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,EAAE,oDAAM;AACR;AACA;AACA;AACA,IAAI,4DAAM;AACV,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH,sBAAsB;AACtB,EAAE,oDAAM;AACR;;AAEA;AACA;AACA;;AAEA,MAAM,kDAAI;AACV,MAAM,kDAAI;AACV,MAAM,kDAAI;AACV,MAAM,kDAAI;;AAEV;AACA,MAAM,4DAAM;AACZ;AACA,GAAG;;AAEH;AACA,EAAE,oDAAM;AACR;AACA;AACA;;AAEA,mCAAmC,kDAAI;AACvC,wBAAwB,kDAAI;AAC5B,sBAAsB,kDAAI;AAC1B,qCAAqC,kDAAI;AACzC;AACA;AACA;AACA,MAAM,kDAAI;AACV,MAAM,kDAAI;AACV,MAAM,kDAAI;AACV,MAAM,kDAAI;AACV;AACA;AACA;AACA,MAAM,kDAAI;AACV,MAAM,kDAAI;AACV,MAAM,kDAAI;AACV,MAAM,kDAAI;AACV;AACA,IAAI,4DAAM;AACV,GAAG;;AAEH,yBAAyB;AACzB,EAAE,oDAAM;AACR;AACA;AACA;AACA;AACA,oBAAoB,kDAAI;AACxB,iBAAiB,yEAAa,CAAC,kDAAI;AACnC,6BAA6B,aAAa;AAC1C,cAAc,kDAAI,aAAa,kDAAI,kCAAkC,kEAAY;AACjF;AACA;AACA,uBAAuB,kDAAI;AAC3B;AACA;AACA;AACA;AACA;AACA,MAAM,kDAAI;AACV,MAAM,kDAAI;AACV,MAAM,kDAAI;AACV,KAAK;AACL,MAAM,kDAAI;AACV;AACA,IAAI,4DAAM;AACV,GAAG;;AAEH,EAAE,oDAAM;AACR,IAAI,kDAAI;AACR,IAAI,4DAAM;AACV;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,iBAAiB,2BAA2B;AAC5C,0CAA0C,kBAAkB;AAC5D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ,kDAAI;AACZ,QAAQ,kDAAI;AACZ;;AAEA;AACA,QAAQ,kDAAI;AACZ,QAAQ,kDAAI;AACZ;;AAEA;AACA,QAAQ,kDAAI;AACZ,OAAO;AACP,QAAQ,kDAAI;AACZ;AACA;AACA,QAAQ,kDAAI;AACZ,OAAO;AACP,QAAQ,kDAAI;AACZ;AACA,MAAM,4DAAM;AACZ,KAAK;AACL;;AAEA;AACA,mBAAmB,2BAA2B;AAC9C,4CAA4C,kBAAkB;AAC9D;AACA,GAAG;;AAEH;AACA,IAAI,kDAAI;AACR,IAAI,kDAAI;AACR,IAAI,kDAAI;AACR,IAAI,kDAAI;AACR,IAAI,kDAAI;AACR,IAAI,kDAAI;AACR,IAAI,4DAAM;AACV,GAAG;;AAEH;AACA;AACA,iBAAiB,oBAAoB;AACrC,+BAA+B,WAAW;AAC1C;AACA,KAAK;AACL;AACA,EAAE,8EAAwB;;AAE1B;AACA,iBAAiB,uBAAuB;AACxC,+BAA+B,cAAc;AAC7C;AACA,KAAK;AACL;AACA;;AAEoC;;;;;;;;;;;;;AC/RpC;AAAA;AAAA;AACA,aAAa,mBAAO,CAAC,0DAAW;;AAEhC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,2BAA2B;AAC9C;AACA;AACA;AACA;AACA,gEAAgE,OAAO,OAAO,QAAQ;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,uBAAuB;AACxC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEwB;;;;;;;;;;;;;AC9ExB;AAAA;AAAA;AAAgD;AACY;;AAE5D,mEAAS;AACT,4DAAM;AACN,uEAAa;;;;;;;;;;;;;ACLb;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEmB;;;;;;;;;;;;;AClBnB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACoC;AACiB;AACZ;;AAEzC;AACA;;AAEA;AACA;AACA;AACA;;AAEA,eAAe,gDAAI;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,qBAAqB;AACnD;AACA;AACA;AACA;AACA;AACA,8BAA8B,qBAAqB;AACnD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,8BAA8B,qBAAqB;AACnD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,8BAA8B,qBAAqB;AACnD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA,kCAAkC,cAAc;AAChD,+BAA+B,WAAW;;AAE1C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iBAAiB,IAAI,iBAAiB;AACtD;;AAEA;AACA;AACA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA,kCAAkC,cAAc;AAChD,+BAA+B,WAAW;AAC1C;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yEAAa;AAC7B,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,EAAE,6DAAW;AACb;;AAEsE;;;;;;;;;;;;;ACjQtE;AAAA;AAAA;AAAA;AAAA;AAAsC;AACe;AACd;;AAEvC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,kDAAI;AACtB;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,kDAAI,MAAM,kDAAI,WAAW,kDAAI;AACtD,0BAA0B,kDAAI,MAAM,kDAAI,WAAW,kDAAI;AACvD,yCAAyC,kDAAI;;AAE7C,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA,0BAA0B,2DAAU;AACpC;;AAEA,oBAAoB,kDAAI;AACxB;AACA,iBAAiB,yEAAa,CAAC,kDAAI;AACnC;AACA;AACA;AACA,4BAA4B,2DAAU,gBAAgB,EAAE;;AAExD;AACA;AACA;AACA;AACA;;AAEuB","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n","var INUMBER = 'INUMBER';\nvar IOP1 = 'IOP1';\nvar IOP2 = 'IOP2';\nvar IOP3 = 'IOP3';\nvar IVAR = 'IVAR';\nvar IVARNAME = 'IVARNAME';\nvar IFUNCALL = 'IFUNCALL';\nvar IFUNDEF = 'IFUNDEF';\nvar IEXPR = 'IEXPR';\nvar IEXPREVAL = 'IEXPREVAL';\nvar IMEMBER = 'IMEMBER';\nvar IENDSTATEMENT = 'IENDSTATEMENT';\nvar IARRAY = 'IARRAY';\n\nfunction Instruction(type, value) {\n  this.type = type;\n  this.value = (value !== undefined && value !== null) ? value : 0;\n}\n\nInstruction.prototype.toString = function () {\n  switch (this.type) {\n    case INUMBER:\n    case IOP1:\n    case IOP2:\n    case IOP3:\n    case IVAR:\n    case IVARNAME:\n    case IENDSTATEMENT:\n      return this.value;\n    case IFUNCALL:\n      return 'CALL ' + this.value;\n    case IFUNDEF:\n      return 'DEF ' + this.value;\n    case IARRAY:\n      return 'ARRAY ' + this.value;\n    case IMEMBER:\n      return '.' + this.value;\n    default:\n      return 'Invalid Instruction';\n  }\n};\n\nfunction unaryInstruction(value) {\n  return new Instruction(IOP1, value);\n}\n\nfunction binaryInstruction(value) {\n  return new Instruction(IOP2, value);\n}\n\nfunction ternaryInstruction(value) {\n  return new Instruction(IOP3, value);\n}\n\nfunction simplify(tokens, unaryOps, binaryOps, ternaryOps, values) {\n  var nstack = [];\n  var newexpression = [];\n  var n1, n2, n3;\n  var f;\n  for (var i = 0; i < tokens.length; i++) {\n    var item = tokens[i];\n    var type = item.type;\n    if (type === INUMBER || type === IVARNAME) {\n      if (Array.isArray(item.value)) {\n        nstack.push.apply(nstack, simplify(item.value.map(function (x) {\n          return new Instruction(INUMBER, x);\n        }).concat(new Instruction(IARRAY, item.value.length)), unaryOps, binaryOps, ternaryOps, values));\n      } else {\n        nstack.push(item);\n      }\n    } else if (type === IVAR && values.hasOwnProperty(item.value)) {\n      item = new Instruction(INUMBER, values[item.value]);\n      nstack.push(item);\n    } else if (type === IOP2 && nstack.length > 1) {\n      n2 = nstack.pop();\n      n1 = nstack.pop();\n      f = binaryOps[item.value];\n      item = new Instruction(INUMBER, f(n1.value, n2.value));\n      nstack.push(item);\n    } else if (type === IOP3 && nstack.length > 2) {\n      n3 = nstack.pop();\n      n2 = nstack.pop();\n      n1 = nstack.pop();\n      if (item.value === '?') {\n        nstack.push(n1.value ? n2.value : n3.value);\n      } else {\n        f = ternaryOps[item.value];\n        item = new Instruction(INUMBER, f(n1.value, n2.value, n3.value));\n        nstack.push(item);\n      }\n    } else if (type === IOP1 && nstack.length > 0) {\n      n1 = nstack.pop();\n      f = unaryOps[item.value];\n      item = new Instruction(INUMBER, f(n1.value));\n      nstack.push(item);\n    } else if (type === IEXPR) {\n      while (nstack.length > 0) {\n        newexpression.push(nstack.shift());\n      }\n      newexpression.push(new Instruction(IEXPR, simplify(item.value, unaryOps, binaryOps, ternaryOps, values)));\n    } else if (type === IMEMBER && nstack.length > 0) {\n      n1 = nstack.pop();\n      nstack.push(new Instruction(INUMBER, n1.value[item.value]));\n    } /* else if (type === IARRAY && nstack.length >= item.value) {\n      var length = item.value;\n      while (length-- > 0) {\n        newexpression.push(nstack.pop());\n      }\n      newexpression.push(new Instruction(IARRAY, item.value));\n    } */ else {\n      while (nstack.length > 0) {\n        newexpression.push(nstack.shift());\n      }\n      newexpression.push(item);\n    }\n  }\n  while (nstack.length > 0) {\n    newexpression.push(nstack.shift());\n  }\n  return newexpression;\n}\n\nfunction substitute(tokens, variable, expr) {\n  var newexpression = [];\n  for (var i = 0; i < tokens.length; i++) {\n    var item = tokens[i];\n    var type = item.type;\n    if (type === IVAR && item.value === variable) {\n      for (var j = 0; j < expr.tokens.length; j++) {\n        var expritem = expr.tokens[j];\n        var replitem;\n        if (expritem.type === IOP1) {\n          replitem = unaryInstruction(expritem.value);\n        } else if (expritem.type === IOP2) {\n          replitem = binaryInstruction(expritem.value);\n        } else if (expritem.type === IOP3) {\n          replitem = ternaryInstruction(expritem.value);\n        } else {\n          replitem = new Instruction(expritem.type, expritem.value);\n        }\n        newexpression.push(replitem);\n      }\n    } else if (type === IEXPR) {\n      newexpression.push(new Instruction(IEXPR, substitute(item.value, variable, expr)));\n    } else {\n      newexpression.push(item);\n    }\n  }\n  return newexpression;\n}\n\nfunction evaluate(tokens, expr, values) {\n  var nstack = [];\n  var n1, n2, n3;\n  var f, args, argCount;\n\n  if (isExpressionEvaluator(tokens)) {\n    return resolveExpression(tokens, values);\n  }\n\n  var numTokens = tokens.length;\n\n  for (var i = 0; i < numTokens; i++) {\n    var item = tokens[i];\n    var type = item.type;\n    if (type === INUMBER || type === IVARNAME) {\n      nstack.push(item.value);\n    } else if (type === IOP2) {\n      n2 = nstack.pop();\n      n1 = nstack.pop();\n      if (item.value === 'and') {\n        nstack.push(n1 ? !!evaluate(n2, expr, values) : false);\n      } else if (item.value === 'or') {\n        nstack.push(n1 ? true : !!evaluate(n2, expr, values));\n      } else if (item.value === '=') {\n        f = expr.binaryOps[item.value];\n        nstack.push(f(n1, evaluate(n2, expr, values), values));\n      } else {\n        f = expr.binaryOps[item.value];\n        nstack.push(f(resolveExpression(n1, values), resolveExpression(n2, values)));\n      }\n    } else if (type === IOP3) {\n      n3 = nstack.pop();\n      n2 = nstack.pop();\n      n1 = nstack.pop();\n      if (item.value === '?') {\n        nstack.push(evaluate(n1 ? n2 : n3, expr, values));\n      } else {\n        f = expr.ternaryOps[item.value];\n        nstack.push(f(resolveExpression(n1, values), resolveExpression(n2, values), resolveExpression(n3, values)));\n      }\n    } else if (type === IVAR) {\n      if (item.value in expr.functions) {\n        nstack.push(expr.functions[item.value]);\n      } else if (item.value in expr.unaryOps && expr.parser.isOperatorEnabled(item.value)) {\n        nstack.push(expr.unaryOps[item.value]);\n      } else {\n        var v = values[item.value];\n        if (v !== undefined) {\n          nstack.push(v);\n        } else {\n          throw new Error('undefined variable: ' + item.value);\n        }\n      }\n    } else if (type === IOP1) {\n      n1 = nstack.pop();\n      f = expr.unaryOps[item.value];\n      nstack.push(f(resolveExpression(n1, values)));\n    } else if (type === IFUNCALL) {\n      argCount = item.value;\n      args = [];\n      while (argCount-- > 0) {\n        args.unshift(resolveExpression(nstack.pop(), values));\n      }\n      f = nstack.pop();\n      if (f.apply && f.call) {\n        nstack.push(f.apply(undefined, args));\n      } else {\n        throw new Error(f + ' is not a function');\n      }\n    } else if (type === IFUNDEF) {\n      // Create closure to keep references to arguments and expression\n      nstack.push((function () {\n        var n2 = nstack.pop();\n        var args = [];\n        var argCount = item.value;\n        while (argCount-- > 0) {\n          args.unshift(nstack.pop());\n        }\n        var n1 = nstack.pop();\n        var f = function () {\n          var scope = Object.assign({}, values);\n          for (var i = 0, len = args.length; i < len; i++) {\n            scope[args[i]] = arguments[i];\n          }\n          return evaluate(n2, expr, scope);\n        };\n        // f.name = n1\n        Object.defineProperty(f, 'name', {\n          value: n1,\n          writable: false\n        });\n        values[n1] = f;\n        return f;\n      })());\n    } else if (type === IEXPR) {\n      nstack.push(createExpressionEvaluator(item, expr));\n    } else if (type === IEXPREVAL) {\n      nstack.push(item);\n    } else if (type === IMEMBER) {\n      n1 = nstack.pop();\n      nstack.push(n1[item.value]);\n    } else if (type === IENDSTATEMENT) {\n      nstack.pop();\n    } else if (type === IARRAY) {\n      argCount = item.value;\n      args = [];\n      while (argCount-- > 0) {\n        args.unshift(nstack.pop());\n      }\n      nstack.push(args);\n    } else {\n      throw new Error('invalid Expression');\n    }\n  }\n  if (nstack.length > 1) {\n    throw new Error('invalid Expression (parity)');\n  }\n  // Explicitly return zero to avoid test issues caused by -0\n  return nstack[0] === 0 ? 0 : resolveExpression(nstack[0], values);\n}\n\nfunction createExpressionEvaluator(token, expr, values) {\n  if (isExpressionEvaluator(token)) return token;\n  return {\n    type: IEXPREVAL,\n    value: function (scope) {\n      return evaluate(token.value, expr, scope);\n    }\n  };\n}\n\nfunction isExpressionEvaluator(n) {\n  return n && n.type === IEXPREVAL;\n}\n\nfunction resolveExpression(n, values) {\n  return isExpressionEvaluator(n) ? n.value(values) : n;\n}\n\nfunction expressionToString(tokens, toJS) {\n  var nstack = [];\n  var n1, n2, n3;\n  var f, args, argCount;\n  for (var i = 0; i < tokens.length; i++) {\n    var item = tokens[i];\n    var type = item.type;\n    if (type === INUMBER) {\n      if (typeof item.value === 'number' && item.value < 0) {\n        nstack.push('(' + item.value + ')');\n      } else if (Array.isArray(item.value)) {\n        nstack.push('[' + item.value.map(escapeValue).join(', ') + ']');\n      } else {\n        nstack.push(escapeValue(item.value));\n      }\n    } else if (type === IOP2) {\n      n2 = nstack.pop();\n      n1 = nstack.pop();\n      f = item.value;\n      if (toJS) {\n        if (f === '^') {\n          nstack.push('Math.pow(' + n1 + ', ' + n2 + ')');\n        } else if (f === 'and') {\n          nstack.push('(!!' + n1 + ' && !!' + n2 + ')');\n        } else if (f === 'or') {\n          nstack.push('(!!' + n1 + ' || !!' + n2 + ')');\n        } else if (f === '||') {\n          nstack.push('(function(a,b){ return Array.isArray(a) && Array.isArray(b) ? a.concat(b) : String(a) + String(b); }((' + n1 + '),(' + n2 + ')))');\n        } else if (f === '==') {\n          nstack.push('(' + n1 + ' === ' + n2 + ')');\n        } else if (f === '!=') {\n          nstack.push('(' + n1 + ' !== ' + n2 + ')');\n        } else if (f === '[') {\n          nstack.push(n1 + '[(' + n2 + ') | 0]');\n        } else {\n          nstack.push('(' + n1 + ' ' + f + ' ' + n2 + ')');\n        }\n      } else {\n        if (f === '[') {\n          nstack.push(n1 + '[' + n2 + ']');\n        } else {\n          nstack.push('(' + n1 + ' ' + f + ' ' + n2 + ')');\n        }\n      }\n    } else if (type === IOP3) {\n      n3 = nstack.pop();\n      n2 = nstack.pop();\n      n1 = nstack.pop();\n      f = item.value;\n      if (f === '?') {\n        nstack.push('(' + n1 + ' ? ' + n2 + ' : ' + n3 + ')');\n      } else {\n        throw new Error('invalid Expression');\n      }\n    } else if (type === IVAR || type === IVARNAME) {\n      nstack.push(item.value);\n    } else if (type === IOP1) {\n      n1 = nstack.pop();\n      f = item.value;\n      if (f === '-' || f === '+') {\n        nstack.push('(' + f + n1 + ')');\n      } else if (toJS) {\n        if (f === 'not') {\n          nstack.push('(' + '!' + n1 + ')');\n        } else if (f === '!') {\n          nstack.push('fac(' + n1 + ')');\n        } else {\n          nstack.push(f + '(' + n1 + ')');\n        }\n      } else if (f === '!') {\n        nstack.push('(' + n1 + '!)');\n      } else {\n        nstack.push('(' + f + ' ' + n1 + ')');\n      }\n    } else if (type === IFUNCALL) {\n      argCount = item.value;\n      args = [];\n      while (argCount-- > 0) {\n        args.unshift(nstack.pop());\n      }\n      f = nstack.pop();\n      nstack.push(f + '(' + args.join(', ') + ')');\n    } else if (type === IFUNDEF) {\n      n2 = nstack.pop();\n      argCount = item.value;\n      args = [];\n      while (argCount-- > 0) {\n        args.unshift(nstack.pop());\n      }\n      n1 = nstack.pop();\n      if (toJS) {\n        nstack.push('(' + n1 + ' = function(' + args.join(', ') + ') { return ' + n2 + ' })');\n      } else {\n        nstack.push('(' + n1 + '(' + args.join(', ') + ') = ' + n2 + ')');\n      }\n    } else if (type === IMEMBER) {\n      n1 = nstack.pop();\n      nstack.push(n1 + '.' + item.value);\n    } else if (type === IARRAY) {\n      argCount = item.value;\n      args = [];\n      while (argCount-- > 0) {\n        args.unshift(nstack.pop());\n      }\n      nstack.push('[' + args.join(', ') + ']');\n    } else if (type === IEXPR) {\n      nstack.push('(' + expressionToString(item.value, toJS) + ')');\n    } else if (type === IENDSTATEMENT) ; else {\n      throw new Error('invalid Expression');\n    }\n  }\n  if (nstack.length > 1) {\n    if (toJS) {\n      nstack = [ nstack.join(',') ];\n    } else {\n      nstack = [ nstack.join(';') ];\n    }\n  }\n  return String(nstack[0]);\n}\n\nfunction escapeValue(v) {\n  if (typeof v === 'string') {\n    return JSON.stringify(v).replace(/\\u2028/g, '\\\\u2028').replace(/\\u2029/g, '\\\\u2029');\n  }\n  return v;\n}\n\nfunction contains(array, obj) {\n  for (var i = 0; i < array.length; i++) {\n    if (array[i] === obj) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction getSymbols(tokens, symbols, options) {\n  options = options || {};\n  var withMembers = !!options.withMembers;\n  var prevVar = null;\n\n  for (var i = 0; i < tokens.length; i++) {\n    var item = tokens[i];\n    if (item.type === IVAR || item.type === IVARNAME) {\n      if (!withMembers && !contains(symbols, item.value)) {\n        symbols.push(item.value);\n      } else if (prevVar !== null) {\n        if (!contains(symbols, prevVar)) {\n          symbols.push(prevVar);\n        }\n        prevVar = item.value;\n      } else {\n        prevVar = item.value;\n      }\n    } else if (item.type === IMEMBER && withMembers && prevVar !== null) {\n      prevVar += '.' + item.value;\n    } else if (item.type === IEXPR) {\n      getSymbols(item.value, symbols, options);\n    } else if (prevVar !== null) {\n      if (!contains(symbols, prevVar)) {\n        symbols.push(prevVar);\n      }\n      prevVar = null;\n    }\n  }\n\n  if (prevVar !== null && !contains(symbols, prevVar)) {\n    symbols.push(prevVar);\n  }\n}\n\nfunction Expression(tokens, parser) {\n  this.tokens = tokens;\n  this.parser = parser;\n  this.unaryOps = parser.unaryOps;\n  this.binaryOps = parser.binaryOps;\n  this.ternaryOps = parser.ternaryOps;\n  this.functions = parser.functions;\n}\n\nExpression.prototype.simplify = function (values) {\n  values = values || {};\n  return new Expression(simplify(this.tokens, this.unaryOps, this.binaryOps, this.ternaryOps, values), this.parser);\n};\n\nExpression.prototype.substitute = function (variable, expr) {\n  if (!(expr instanceof Expression)) {\n    expr = this.parser.parse(String(expr));\n  }\n\n  return new Expression(substitute(this.tokens, variable, expr), this.parser);\n};\n\nExpression.prototype.evaluate = function (values) {\n  values = values || {};\n  return evaluate(this.tokens, this, values);\n};\n\nExpression.prototype.toString = function () {\n  return expressionToString(this.tokens, false);\n};\n\nExpression.prototype.symbols = function (options) {\n  options = options || {};\n  var vars = [];\n  getSymbols(this.tokens, vars, options);\n  return vars;\n};\n\nExpression.prototype.variables = function (options) {\n  options = options || {};\n  var vars = [];\n  getSymbols(this.tokens, vars, options);\n  var functions = this.functions;\n  return vars.filter(function (name) {\n    return !(name in functions);\n  });\n};\n\nExpression.prototype.toJSFunction = function (param, variables) {\n  var expr = this;\n  var f = new Function(param, 'with(this.functions) with (this.ternaryOps) with (this.binaryOps) with (this.unaryOps) { return ' + expressionToString(this.simplify(variables).tokens, true) + '; }'); // eslint-disable-line no-new-func\n  return function () {\n    return f.apply(expr, arguments);\n  };\n};\n\nvar TEOF = 'TEOF';\nvar TOP = 'TOP';\nvar TNUMBER = 'TNUMBER';\nvar TSTRING = 'TSTRING';\nvar TPAREN = 'TPAREN';\nvar TBRACKET = 'TBRACKET';\nvar TCOMMA = 'TCOMMA';\nvar TNAME = 'TNAME';\nvar TSEMICOLON = 'TSEMICOLON';\n\nfunction Token(type, value, index) {\n  this.type = type;\n  this.value = value;\n  this.index = index;\n}\n\nToken.prototype.toString = function () {\n  return this.type + ': ' + this.value;\n};\n\nfunction TokenStream(parser, expression) {\n  this.pos = 0;\n  this.current = null;\n  this.unaryOps = parser.unaryOps;\n  this.binaryOps = parser.binaryOps;\n  this.ternaryOps = parser.ternaryOps;\n  this.consts = parser.consts;\n  this.expression = expression;\n  this.savedPosition = 0;\n  this.savedCurrent = null;\n  this.options = parser.options;\n  this.parser = parser;\n}\n\nTokenStream.prototype.newToken = function (type, value, pos) {\n  return new Token(type, value, pos != null ? pos : this.pos);\n};\n\nTokenStream.prototype.save = function () {\n  this.savedPosition = this.pos;\n  this.savedCurrent = this.current;\n};\n\nTokenStream.prototype.restore = function () {\n  this.pos = this.savedPosition;\n  this.current = this.savedCurrent;\n};\n\nTokenStream.prototype.next = function () {\n  if (this.pos >= this.expression.length) {\n    return this.newToken(TEOF, 'EOF');\n  }\n\n  if (this.isWhitespace() || this.isComment()) {\n    return this.next();\n  } else if (this.isRadixInteger() ||\n      this.isNumber() ||\n      this.isOperator() ||\n      this.isString() ||\n      this.isParen() ||\n      this.isBracket() ||\n      this.isComma() ||\n      this.isSemicolon() ||\n      this.isNamedOp() ||\n      this.isConst() ||\n      this.isName()) {\n    return this.current;\n  } else {\n    this.parseError('Unknown character \"' + this.expression.charAt(this.pos) + '\"');\n  }\n};\n\nTokenStream.prototype.isString = function () {\n  var r = false;\n  var startPos = this.pos;\n  var quote = this.expression.charAt(startPos);\n\n  if (quote === '\\'' || quote === '\"') {\n    var index = this.expression.indexOf(quote, startPos + 1);\n    while (index >= 0 && this.pos < this.expression.length) {\n      this.pos = index + 1;\n      if (this.expression.charAt(index - 1) !== '\\\\') {\n        var rawString = this.expression.substring(startPos + 1, index);\n        this.current = this.newToken(TSTRING, this.unescape(rawString), startPos);\n        r = true;\n        break;\n      }\n      index = this.expression.indexOf(quote, index + 1);\n    }\n  }\n  return r;\n};\n\nTokenStream.prototype.isParen = function () {\n  var c = this.expression.charAt(this.pos);\n  if (c === '(' || c === ')') {\n    this.current = this.newToken(TPAREN, c);\n    this.pos++;\n    return true;\n  }\n  return false;\n};\n\nTokenStream.prototype.isBracket = function () {\n  var c = this.expression.charAt(this.pos);\n  if ((c === '[' || c === ']') && this.isOperatorEnabled('[')) {\n    this.current = this.newToken(TBRACKET, c);\n    this.pos++;\n    return true;\n  }\n  return false;\n};\n\nTokenStream.prototype.isComma = function () {\n  var c = this.expression.charAt(this.pos);\n  if (c === ',') {\n    this.current = this.newToken(TCOMMA, ',');\n    this.pos++;\n    return true;\n  }\n  return false;\n};\n\nTokenStream.prototype.isSemicolon = function () {\n  var c = this.expression.charAt(this.pos);\n  if (c === ';') {\n    this.current = this.newToken(TSEMICOLON, ';');\n    this.pos++;\n    return true;\n  }\n  return false;\n};\n\nTokenStream.prototype.isConst = function () {\n  var startPos = this.pos;\n  var i = startPos;\n  for (; i < this.expression.length; i++) {\n    var c = this.expression.charAt(i);\n    if (c.toUpperCase() === c.toLowerCase()) {\n      if (i === this.pos || (c !== '_' && c !== '.' && (c < '0' || c > '9'))) {\n        break;\n      }\n    }\n  }\n  if (i > startPos) {\n    var str = this.expression.substring(startPos, i);\n    if (str in this.consts) {\n      this.current = this.newToken(TNUMBER, this.consts[str]);\n      this.pos += str.length;\n      return true;\n    }\n  }\n  return false;\n};\n\nTokenStream.prototype.isNamedOp = function () {\n  var startPos = this.pos;\n  var i = startPos;\n  for (; i < this.expression.length; i++) {\n    var c = this.expression.charAt(i);\n    if (c.toUpperCase() === c.toLowerCase()) {\n      if (i === this.pos || (c !== '_' && (c < '0' || c > '9'))) {\n        break;\n      }\n    }\n  }\n  if (i > startPos) {\n    var str = this.expression.substring(startPos, i);\n    if (this.isOperatorEnabled(str) && (str in this.binaryOps || str in this.unaryOps || str in this.ternaryOps)) {\n      this.current = this.newToken(TOP, str);\n      this.pos += str.length;\n      return true;\n    }\n  }\n  return false;\n};\n\nTokenStream.prototype.isName = function () {\n  var startPos = this.pos;\n  var i = startPos;\n  var hasLetter = false;\n  for (; i < this.expression.length; i++) {\n    var c = this.expression.charAt(i);\n    if (c.toUpperCase() === c.toLowerCase()) {\n      if (i === this.pos && (c === '$' || c === '_')) {\n        if (c === '_') {\n          hasLetter = true;\n        }\n        continue;\n      } else if (i === this.pos || !hasLetter || (c !== '_' && (c < '0' || c > '9'))) {\n        break;\n      }\n    } else {\n      hasLetter = true;\n    }\n  }\n  if (hasLetter) {\n    var str = this.expression.substring(startPos, i);\n    this.current = this.newToken(TNAME, str);\n    this.pos += str.length;\n    return true;\n  }\n  return false;\n};\n\nTokenStream.prototype.isWhitespace = function () {\n  var r = false;\n  var c = this.expression.charAt(this.pos);\n  while (c === ' ' || c === '\\t' || c === '\\n' || c === '\\r') {\n    r = true;\n    this.pos++;\n    if (this.pos >= this.expression.length) {\n      break;\n    }\n    c = this.expression.charAt(this.pos);\n  }\n  return r;\n};\n\nvar codePointPattern = /^[0-9a-f]{4}$/i;\n\nTokenStream.prototype.unescape = function (v) {\n  var index = v.indexOf('\\\\');\n  if (index < 0) {\n    return v;\n  }\n\n  var buffer = v.substring(0, index);\n  while (index >= 0) {\n    var c = v.charAt(++index);\n    switch (c) {\n      case '\\'':\n        buffer += '\\'';\n        break;\n      case '\"':\n        buffer += '\"';\n        break;\n      case '\\\\':\n        buffer += '\\\\';\n        break;\n      case '/':\n        buffer += '/';\n        break;\n      case 'b':\n        buffer += '\\b';\n        break;\n      case 'f':\n        buffer += '\\f';\n        break;\n      case 'n':\n        buffer += '\\n';\n        break;\n      case 'r':\n        buffer += '\\r';\n        break;\n      case 't':\n        buffer += '\\t';\n        break;\n      case 'u':\n        // interpret the following 4 characters as the hex of the unicode code point\n        var codePoint = v.substring(index + 1, index + 5);\n        if (!codePointPattern.test(codePoint)) {\n          this.parseError('Illegal escape sequence: \\\\u' + codePoint);\n        }\n        buffer += String.fromCharCode(parseInt(codePoint, 16));\n        index += 4;\n        break;\n      default:\n        throw this.parseError('Illegal escape sequence: \"\\\\' + c + '\"');\n    }\n    ++index;\n    var backslash = v.indexOf('\\\\', index);\n    buffer += v.substring(index, backslash < 0 ? v.length : backslash);\n    index = backslash;\n  }\n\n  return buffer;\n};\n\nTokenStream.prototype.isComment = function () {\n  var c = this.expression.charAt(this.pos);\n  if (c === '/' && this.expression.charAt(this.pos + 1) === '*') {\n    this.pos = this.expression.indexOf('*/', this.pos) + 2;\n    if (this.pos === 1) {\n      this.pos = this.expression.length;\n    }\n    return true;\n  }\n  return false;\n};\n\nTokenStream.prototype.isRadixInteger = function () {\n  var pos = this.pos;\n\n  if (pos >= this.expression.length - 2 || this.expression.charAt(pos) !== '0') {\n    return false;\n  }\n  ++pos;\n\n  var radix;\n  var validDigit;\n  if (this.expression.charAt(pos) === 'x') {\n    radix = 16;\n    validDigit = /^[0-9a-f]$/i;\n    ++pos;\n  } else if (this.expression.charAt(pos) === 'b') {\n    radix = 2;\n    validDigit = /^[01]$/i;\n    ++pos;\n  } else {\n    return false;\n  }\n\n  var valid = false;\n  var startPos = pos;\n\n  while (pos < this.expression.length) {\n    var c = this.expression.charAt(pos);\n    if (validDigit.test(c)) {\n      pos++;\n      valid = true;\n    } else {\n      break;\n    }\n  }\n\n  if (valid) {\n    this.current = this.newToken(TNUMBER, parseInt(this.expression.substring(startPos, pos), radix));\n    this.pos = pos;\n  }\n  return valid;\n};\n\nTokenStream.prototype.isNumber = function () {\n  var valid = false;\n  var pos = this.pos;\n  var startPos = pos;\n  var resetPos = pos;\n  var foundDot = false;\n  var foundDigits = false;\n  var c;\n\n  while (pos < this.expression.length) {\n    c = this.expression.charAt(pos);\n    if ((c >= '0' && c <= '9') || (!foundDot && c === '.')) {\n      if (c === '.') {\n        foundDot = true;\n      } else {\n        foundDigits = true;\n      }\n      pos++;\n      valid = foundDigits;\n    } else {\n      break;\n    }\n  }\n\n  if (valid) {\n    resetPos = pos;\n  }\n\n  if (c === 'e' || c === 'E') {\n    pos++;\n    var acceptSign = true;\n    var validExponent = false;\n    while (pos < this.expression.length) {\n      c = this.expression.charAt(pos);\n      if (acceptSign && (c === '+' || c === '-')) {\n        acceptSign = false;\n      } else if (c >= '0' && c <= '9') {\n        validExponent = true;\n        acceptSign = false;\n      } else {\n        break;\n      }\n      pos++;\n    }\n\n    if (!validExponent) {\n      pos = resetPos;\n    }\n  }\n\n  if (valid) {\n    this.current = this.newToken(TNUMBER, parseFloat(this.expression.substring(startPos, pos)));\n    this.pos = pos;\n  } else {\n    this.pos = resetPos;\n  }\n  return valid;\n};\n\nTokenStream.prototype.isOperator = function () {\n  var startPos = this.pos;\n  var c = this.expression.charAt(this.pos);\n\n  if (c === '+' || c === '-' || c === '*' || c === '/' || c === '%' || c === '^' || c === '?' || c === ':' || c === '.') {\n    this.current = this.newToken(TOP, c);\n  } else if (c === '∙' || c === '•') {\n    this.current = this.newToken(TOP, '*');\n  } else if (c === '>') {\n    if (this.expression.charAt(this.pos + 1) === '=') {\n      this.current = this.newToken(TOP, '>=');\n      this.pos++;\n    } else {\n      this.current = this.newToken(TOP, '>');\n    }\n  } else if (c === '<') {\n    if (this.expression.charAt(this.pos + 1) === '=') {\n      this.current = this.newToken(TOP, '<=');\n      this.pos++;\n    } else {\n      this.current = this.newToken(TOP, '<');\n    }\n  } else if (c === '|') {\n    if (this.expression.charAt(this.pos + 1) === '|') {\n      this.current = this.newToken(TOP, '||');\n      this.pos++;\n    } else {\n      return false;\n    }\n  } else if (c === '=') {\n    if (this.expression.charAt(this.pos + 1) === '=') {\n      this.current = this.newToken(TOP, '==');\n      this.pos++;\n    } else {\n      this.current = this.newToken(TOP, c);\n    }\n  } else if (c === '!') {\n    if (this.expression.charAt(this.pos + 1) === '=') {\n      this.current = this.newToken(TOP, '!=');\n      this.pos++;\n    } else {\n      this.current = this.newToken(TOP, c);\n    }\n  } else {\n    return false;\n  }\n  this.pos++;\n\n  if (this.isOperatorEnabled(this.current.value)) {\n    return true;\n  } else {\n    this.pos = startPos;\n    return false;\n  }\n};\n\nTokenStream.prototype.isOperatorEnabled = function (op) {\n  return this.parser.isOperatorEnabled(op);\n};\n\nTokenStream.prototype.getCoordinates = function () {\n  var line = 0;\n  var column;\n  var newline = -1;\n  do {\n    line++;\n    column = this.pos - newline;\n    newline = this.expression.indexOf('\\n', newline + 1);\n  } while (newline >= 0 && newline < this.pos);\n\n  return {\n    line: line,\n    column: column\n  };\n};\n\nTokenStream.prototype.parseError = function (msg) {\n  var coords = this.getCoordinates();\n  throw new Error('parse error [' + coords.line + ':' + coords.column + ']: ' + msg);\n};\n\nfunction ParserState(parser, tokenStream, options) {\n  this.parser = parser;\n  this.tokens = tokenStream;\n  this.current = null;\n  this.nextToken = null;\n  this.next();\n  this.savedCurrent = null;\n  this.savedNextToken = null;\n  this.allowMemberAccess = options.allowMemberAccess !== false;\n}\n\nParserState.prototype.next = function () {\n  this.current = this.nextToken;\n  return (this.nextToken = this.tokens.next());\n};\n\nParserState.prototype.tokenMatches = function (token, value) {\n  if (typeof value === 'undefined') {\n    return true;\n  } else if (Array.isArray(value)) {\n    return contains(value, token.value);\n  } else if (typeof value === 'function') {\n    return value(token);\n  } else {\n    return token.value === value;\n  }\n};\n\nParserState.prototype.save = function () {\n  this.savedCurrent = this.current;\n  this.savedNextToken = this.nextToken;\n  this.tokens.save();\n};\n\nParserState.prototype.restore = function () {\n  this.tokens.restore();\n  this.current = this.savedCurrent;\n  this.nextToken = this.savedNextToken;\n};\n\nParserState.prototype.accept = function (type, value) {\n  if (this.nextToken.type === type && this.tokenMatches(this.nextToken, value)) {\n    this.next();\n    return true;\n  }\n  return false;\n};\n\nParserState.prototype.expect = function (type, value) {\n  if (!this.accept(type, value)) {\n    var coords = this.tokens.getCoordinates();\n    throw new Error('parse error [' + coords.line + ':' + coords.column + ']: Expected ' + (value || type));\n  }\n};\n\nParserState.prototype.parseAtom = function (instr) {\n  var unaryOps = this.tokens.unaryOps;\n  function isPrefixOperator(token) {\n    return token.value in unaryOps;\n  }\n\n  if (this.accept(TNAME) || this.accept(TOP, isPrefixOperator)) {\n    instr.push(new Instruction(IVAR, this.current.value));\n  } else if (this.accept(TNUMBER)) {\n    instr.push(new Instruction(INUMBER, this.current.value));\n  } else if (this.accept(TSTRING)) {\n    instr.push(new Instruction(INUMBER, this.current.value));\n  } else if (this.accept(TPAREN, '(')) {\n    this.parseExpression(instr);\n    this.expect(TPAREN, ')');\n  } else if (this.accept(TBRACKET, '[')) {\n    if (this.accept(TBRACKET, ']')) {\n      instr.push(new Instruction(IARRAY, 0));\n    } else {\n      var argCount = this.parseArrayList(instr);\n      instr.push(new Instruction(IARRAY, argCount));\n    }\n  } else {\n    throw new Error('unexpected ' + this.nextToken);\n  }\n};\n\nParserState.prototype.parseExpression = function (instr) {\n  var exprInstr = [];\n  if (this.parseUntilEndStatement(instr, exprInstr)) {\n    return;\n  }\n  this.parseVariableAssignmentExpression(exprInstr);\n  if (this.parseUntilEndStatement(instr, exprInstr)) {\n    return;\n  }\n  this.pushExpression(instr, exprInstr);\n};\n\nParserState.prototype.pushExpression = function (instr, exprInstr) {\n  for (var i = 0, len = exprInstr.length; i < len; i++) {\n    instr.push(exprInstr[i]);\n  }\n};\n\nParserState.prototype.parseUntilEndStatement = function (instr, exprInstr) {\n  if (!this.accept(TSEMICOLON)) return false;\n  if (this.nextToken && this.nextToken.type !== TEOF && !(this.nextToken.type === TPAREN && this.nextToken.value === ')')) {\n    exprInstr.push(new Instruction(IENDSTATEMENT));\n  }\n  if (this.nextToken.type !== TEOF) {\n    this.parseExpression(exprInstr);\n  }\n  instr.push(new Instruction(IEXPR, exprInstr));\n  return true;\n};\n\nParserState.prototype.parseArrayList = function (instr) {\n  var argCount = 0;\n\n  while (!this.accept(TBRACKET, ']')) {\n    this.parseExpression(instr);\n    ++argCount;\n    while (this.accept(TCOMMA)) {\n      this.parseExpression(instr);\n      ++argCount;\n    }\n  }\n\n  return argCount;\n};\n\nParserState.prototype.parseVariableAssignmentExpression = function (instr) {\n  this.parseConditionalExpression(instr);\n  while (this.accept(TOP, '=')) {\n    var varName = instr.pop();\n    var varValue = [];\n    var lastInstrIndex = instr.length - 1;\n    if (varName.type === IFUNCALL) {\n      if (!this.tokens.isOperatorEnabled('()=')) {\n        throw new Error('function definition is not permitted');\n      }\n      for (var i = 0, len = varName.value + 1; i < len; i++) {\n        var index = lastInstrIndex - i;\n        if (instr[index].type === IVAR) {\n          instr[index] = new Instruction(IVARNAME, instr[index].value);\n        }\n      }\n      this.parseVariableAssignmentExpression(varValue);\n      instr.push(new Instruction(IEXPR, varValue));\n      instr.push(new Instruction(IFUNDEF, varName.value));\n      continue;\n    }\n    if (varName.type !== IVAR && varName.type !== IMEMBER) {\n      throw new Error('expected variable for assignment');\n    }\n    this.parseVariableAssignmentExpression(varValue);\n    instr.push(new Instruction(IVARNAME, varName.value));\n    instr.push(new Instruction(IEXPR, varValue));\n    instr.push(binaryInstruction('='));\n  }\n};\n\nParserState.prototype.parseConditionalExpression = function (instr) {\n  this.parseOrExpression(instr);\n  while (this.accept(TOP, '?')) {\n    var trueBranch = [];\n    var falseBranch = [];\n    this.parseConditionalExpression(trueBranch);\n    this.expect(TOP, ':');\n    this.parseConditionalExpression(falseBranch);\n    instr.push(new Instruction(IEXPR, trueBranch));\n    instr.push(new Instruction(IEXPR, falseBranch));\n    instr.push(ternaryInstruction('?'));\n  }\n};\n\nParserState.prototype.parseOrExpression = function (instr) {\n  this.parseAndExpression(instr);\n  while (this.accept(TOP, 'or')) {\n    var falseBranch = [];\n    this.parseAndExpression(falseBranch);\n    instr.push(new Instruction(IEXPR, falseBranch));\n    instr.push(binaryInstruction('or'));\n  }\n};\n\nParserState.prototype.parseAndExpression = function (instr) {\n  this.parseComparison(instr);\n  while (this.accept(TOP, 'and')) {\n    var trueBranch = [];\n    this.parseComparison(trueBranch);\n    instr.push(new Instruction(IEXPR, trueBranch));\n    instr.push(binaryInstruction('and'));\n  }\n};\n\nvar COMPARISON_OPERATORS = ['==', '!=', '<', '<=', '>=', '>', 'in'];\n\nParserState.prototype.parseComparison = function (instr) {\n  this.parseAddSub(instr);\n  while (this.accept(TOP, COMPARISON_OPERATORS)) {\n    var op = this.current;\n    this.parseAddSub(instr);\n    instr.push(binaryInstruction(op.value));\n  }\n};\n\nvar ADD_SUB_OPERATORS = ['+', '-', '||'];\n\nParserState.prototype.parseAddSub = function (instr) {\n  this.parseTerm(instr);\n  while (this.accept(TOP, ADD_SUB_OPERATORS)) {\n    var op = this.current;\n    this.parseTerm(instr);\n    instr.push(binaryInstruction(op.value));\n  }\n};\n\nvar TERM_OPERATORS = ['*', '/', '%'];\n\nParserState.prototype.parseTerm = function (instr) {\n  this.parseFactor(instr);\n  while (this.accept(TOP, TERM_OPERATORS)) {\n    var op = this.current;\n    this.parseFactor(instr);\n    instr.push(binaryInstruction(op.value));\n  }\n};\n\nParserState.prototype.parseFactor = function (instr) {\n  var unaryOps = this.tokens.unaryOps;\n  function isPrefixOperator(token) {\n    return token.value in unaryOps;\n  }\n\n  this.save();\n  if (this.accept(TOP, isPrefixOperator)) {\n    if (this.current.value !== '-' && this.current.value !== '+') {\n      if (this.nextToken.type === TPAREN && this.nextToken.value === '(') {\n        this.restore();\n        this.parseExponential(instr);\n        return;\n      } else if (this.nextToken.type === TSEMICOLON || this.nextToken.type === TCOMMA || this.nextToken.type === TEOF || (this.nextToken.type === TPAREN && this.nextToken.value === ')')) {\n        this.restore();\n        this.parseAtom(instr);\n        return;\n      }\n    }\n\n    var op = this.current;\n    this.parseFactor(instr);\n    instr.push(unaryInstruction(op.value));\n  } else {\n    this.parseExponential(instr);\n  }\n};\n\nParserState.prototype.parseExponential = function (instr) {\n  this.parsePostfixExpression(instr);\n  while (this.accept(TOP, '^')) {\n    this.parseFactor(instr);\n    instr.push(binaryInstruction('^'));\n  }\n};\n\nParserState.prototype.parsePostfixExpression = function (instr) {\n  this.parseFunctionCall(instr);\n  while (this.accept(TOP, '!')) {\n    instr.push(unaryInstruction('!'));\n  }\n};\n\nParserState.prototype.parseFunctionCall = function (instr) {\n  var unaryOps = this.tokens.unaryOps;\n  function isPrefixOperator(token) {\n    return token.value in unaryOps;\n  }\n\n  if (this.accept(TOP, isPrefixOperator)) {\n    var op = this.current;\n    this.parseAtom(instr);\n    instr.push(unaryInstruction(op.value));\n  } else {\n    this.parseMemberExpression(instr);\n    while (this.accept(TPAREN, '(')) {\n      if (this.accept(TPAREN, ')')) {\n        instr.push(new Instruction(IFUNCALL, 0));\n      } else {\n        var argCount = this.parseArgumentList(instr);\n        instr.push(new Instruction(IFUNCALL, argCount));\n      }\n    }\n  }\n};\n\nParserState.prototype.parseArgumentList = function (instr) {\n  var argCount = 0;\n\n  while (!this.accept(TPAREN, ')')) {\n    this.parseExpression(instr);\n    ++argCount;\n    while (this.accept(TCOMMA)) {\n      this.parseExpression(instr);\n      ++argCount;\n    }\n  }\n\n  return argCount;\n};\n\nParserState.prototype.parseMemberExpression = function (instr) {\n  this.parseAtom(instr);\n  while (this.accept(TOP, '.') || this.accept(TBRACKET, '[')) {\n    var op = this.current;\n\n    if (op.value === '.') {\n      if (!this.allowMemberAccess) {\n        throw new Error('unexpected \".\", member access is not permitted');\n      }\n\n      this.expect(TNAME);\n      instr.push(new Instruction(IMEMBER, this.current.value));\n    } else if (op.value === '[') {\n      if (!this.tokens.isOperatorEnabled('[')) {\n        throw new Error('unexpected \"[]\", arrays are disabled');\n      }\n\n      this.parseExpression(instr);\n      this.expect(TBRACKET, ']');\n      instr.push(binaryInstruction('['));\n    } else {\n      throw new Error('unexpected symbol: ' + op.value);\n    }\n  }\n};\n\nfunction add(a, b) {\n  return Number(a) + Number(b);\n}\n\nfunction sub(a, b) {\n  return a - b;\n}\n\nfunction mul(a, b) {\n  return a * b;\n}\n\nfunction div(a, b) {\n  return a / b;\n}\n\nfunction mod(a, b) {\n  return a % b;\n}\n\nfunction concat(a, b) {\n  if (Array.isArray(a) && Array.isArray(b)) {\n    return a.concat(b);\n  }\n  return '' + a + b;\n}\n\nfunction equal(a, b) {\n  return a === b;\n}\n\nfunction notEqual(a, b) {\n  return a !== b;\n}\n\nfunction greaterThan(a, b) {\n  return a > b;\n}\n\nfunction lessThan(a, b) {\n  return a < b;\n}\n\nfunction greaterThanEqual(a, b) {\n  return a >= b;\n}\n\nfunction lessThanEqual(a, b) {\n  return a <= b;\n}\n\nfunction andOperator(a, b) {\n  return Boolean(a && b);\n}\n\nfunction orOperator(a, b) {\n  return Boolean(a || b);\n}\n\nfunction inOperator(a, b) {\n  return contains(b, a);\n}\n\nfunction sinh(a) {\n  return ((Math.exp(a) - Math.exp(-a)) / 2);\n}\n\nfunction cosh(a) {\n  return ((Math.exp(a) + Math.exp(-a)) / 2);\n}\n\nfunction tanh(a) {\n  if (a === Infinity) return 1;\n  if (a === -Infinity) return -1;\n  return (Math.exp(a) - Math.exp(-a)) / (Math.exp(a) + Math.exp(-a));\n}\n\nfunction asinh(a) {\n  if (a === -Infinity) return a;\n  return Math.log(a + Math.sqrt((a * a) + 1));\n}\n\nfunction acosh(a) {\n  return Math.log(a + Math.sqrt((a * a) - 1));\n}\n\nfunction atanh(a) {\n  return (Math.log((1 + a) / (1 - a)) / 2);\n}\n\nfunction log10(a) {\n  return Math.log(a) * Math.LOG10E;\n}\n\nfunction neg(a) {\n  return -a;\n}\n\nfunction not(a) {\n  return !a;\n}\n\nfunction trunc(a) {\n  return a < 0 ? Math.ceil(a) : Math.floor(a);\n}\n\nfunction random(a) {\n  return Math.random() * (a || 1);\n}\n\nfunction factorial(a) { // a!\n  return gamma(a + 1);\n}\n\nfunction isInteger(value) {\n  return isFinite(value) && (value === Math.round(value));\n}\n\nvar GAMMA_G = 4.7421875;\nvar GAMMA_P = [\n  0.99999999999999709182,\n  57.156235665862923517, -59.597960355475491248,\n  14.136097974741747174, -0.49191381609762019978,\n  0.33994649984811888699e-4,\n  0.46523628927048575665e-4, -0.98374475304879564677e-4,\n  0.15808870322491248884e-3, -0.21026444172410488319e-3,\n  0.21743961811521264320e-3, -0.16431810653676389022e-3,\n  0.84418223983852743293e-4, -0.26190838401581408670e-4,\n  0.36899182659531622704e-5\n];\n\n// Gamma function from math.js\nfunction gamma(n) {\n  var t, x;\n\n  if (isInteger(n)) {\n    if (n <= 0) {\n      return isFinite(n) ? Infinity : NaN;\n    }\n\n    if (n > 171) {\n      return Infinity; // Will overflow\n    }\n\n    var value = n - 2;\n    var res = n - 1;\n    while (value > 1) {\n      res *= value;\n      value--;\n    }\n\n    if (res === 0) {\n      res = 1; // 0! is per definition 1\n    }\n\n    return res;\n  }\n\n  if (n < 0.5) {\n    return Math.PI / (Math.sin(Math.PI * n) * gamma(1 - n));\n  }\n\n  if (n >= 171.35) {\n    return Infinity; // will overflow\n  }\n\n  if (n > 85.0) { // Extended Stirling Approx\n    var twoN = n * n;\n    var threeN = twoN * n;\n    var fourN = threeN * n;\n    var fiveN = fourN * n;\n    return Math.sqrt(2 * Math.PI / n) * Math.pow((n / Math.E), n) *\n      (1 + (1 / (12 * n)) + (1 / (288 * twoN)) - (139 / (51840 * threeN)) -\n      (571 / (2488320 * fourN)) + (163879 / (209018880 * fiveN)) +\n      (5246819 / (75246796800 * fiveN * n)));\n  }\n\n  --n;\n  x = GAMMA_P[0];\n  for (var i = 1; i < GAMMA_P.length; ++i) {\n    x += GAMMA_P[i] / (n + i);\n  }\n\n  t = n + GAMMA_G + 0.5;\n  return Math.sqrt(2 * Math.PI) * Math.pow(t, n + 0.5) * Math.exp(-t) * x;\n}\n\nfunction stringOrArrayLength(s) {\n  if (Array.isArray(s)) {\n    return s.length;\n  }\n  return String(s).length;\n}\n\nfunction hypot() {\n  var sum = 0;\n  var larg = 0;\n  for (var i = 0; i < arguments.length; i++) {\n    var arg = Math.abs(arguments[i]);\n    var div;\n    if (larg < arg) {\n      div = larg / arg;\n      sum = (sum * div * div) + 1;\n      larg = arg;\n    } else if (arg > 0) {\n      div = arg / larg;\n      sum += div * div;\n    } else {\n      sum += arg;\n    }\n  }\n  return larg === Infinity ? Infinity : larg * Math.sqrt(sum);\n}\n\nfunction condition(cond, yep, nope) {\n  return cond ? yep : nope;\n}\n\n/**\n* Decimal adjustment of a number.\n* From @escopecz.\n*\n* @param {Number} value The number.\n* @param {Integer} exp  The exponent (the 10 logarithm of the adjustment base).\n* @return {Number} The adjusted value.\n*/\nfunction roundTo(value, exp) {\n  // If the exp is undefined or zero...\n  if (typeof exp === 'undefined' || +exp === 0) {\n    return Math.round(value);\n  }\n  value = +value;\n  exp = -(+exp);\n  // If the value is not a number or the exp is not an integer...\n  if (isNaN(value) || !(typeof exp === 'number' && exp % 1 === 0)) {\n    return NaN;\n  }\n  // Shift\n  value = value.toString().split('e');\n  value = Math.round(+(value[0] + 'e' + (value[1] ? (+value[1] - exp) : -exp)));\n  // Shift back\n  value = value.toString().split('e');\n  return +(value[0] + 'e' + (value[1] ? (+value[1] + exp) : exp));\n}\n\nfunction setVar(name, value, variables) {\n  if (variables) variables[name] = value;\n  return value;\n}\n\nfunction arrayIndex(array, index) {\n  return array[index | 0];\n}\n\nfunction max(array) {\n  if (arguments.length === 1 && Array.isArray(array)) {\n    return Math.max.apply(Math, array);\n  } else {\n    return Math.max.apply(Math, arguments);\n  }\n}\n\nfunction min(array) {\n  if (arguments.length === 1 && Array.isArray(array)) {\n    return Math.min.apply(Math, array);\n  } else {\n    return Math.min.apply(Math, arguments);\n  }\n}\n\nfunction arrayMap(f, a) {\n  if (typeof f !== 'function') {\n    throw new Error('First argument to map is not a function');\n  }\n  if (!Array.isArray(a)) {\n    throw new Error('Second argument to map is not an array');\n  }\n  return a.map(function (x, i) {\n    return f(x, i);\n  });\n}\n\nfunction arrayFold(f, init, a) {\n  if (typeof f !== 'function') {\n    throw new Error('First argument to fold is not a function');\n  }\n  if (!Array.isArray(a)) {\n    throw new Error('Second argument to fold is not an array');\n  }\n  return a.reduce(function (acc, x, i) {\n    return f(acc, x, i);\n  }, init);\n}\n\nfunction arrayFilter(f, a) {\n  if (typeof f !== 'function') {\n    throw new Error('First argument to filter is not a function');\n  }\n  if (!Array.isArray(a)) {\n    throw new Error('Second argument to filter is not an array');\n  }\n  return a.filter(function (x, i) {\n    return f(x, i);\n  });\n}\n\nfunction stringOrArrayIndexOf(target, s) {\n  if (!(Array.isArray(s) || typeof s === 'string')) {\n    throw new Error('Second argument to indexOf is not a string or array');\n  }\n\n  return s.indexOf(target);\n}\n\nfunction arrayJoin(sep, a) {\n  if (!Array.isArray(a)) {\n    throw new Error('Second argument to join is not an array');\n  }\n\n  return a.join(sep);\n}\n\nfunction sign(x) {\n  return ((x > 0) - (x < 0)) || +x;\n}\n\nvar ONE_THIRD = 1/3;\nfunction cbrt(x) {\n  return x < 0 ? -Math.pow(-x, ONE_THIRD) : Math.pow(x, ONE_THIRD);\n}\n\nfunction expm1(x) {\n  return Math.exp(x) - 1;\n}\n\nfunction log1p(x) {\n  return Math.log(1 + x);\n}\n\nfunction log2(x) {\n  return Math.log(x) / Math.LN2;\n}\n\nfunction Parser(options) {\n  this.options = options || {};\n  this.unaryOps = {\n    sin: Math.sin,\n    cos: Math.cos,\n    tan: Math.tan,\n    asin: Math.asin,\n    acos: Math.acos,\n    atan: Math.atan,\n    sinh: Math.sinh || sinh,\n    cosh: Math.cosh || cosh,\n    tanh: Math.tanh || tanh,\n    asinh: Math.asinh || asinh,\n    acosh: Math.acosh || acosh,\n    atanh: Math.atanh || atanh,\n    sqrt: Math.sqrt,\n    cbrt: Math.cbrt || cbrt,\n    log: Math.log,\n    log2: Math.log2 || log2,\n    ln: Math.log,\n    lg: Math.log10 || log10,\n    log10: Math.log10 || log10,\n    expm1: Math.expm1 || expm1,\n    log1p: Math.log1p || log1p,\n    abs: Math.abs,\n    ceil: Math.ceil,\n    floor: Math.floor,\n    round: Math.round,\n    trunc: Math.trunc || trunc,\n    '-': neg,\n    '+': Number,\n    exp: Math.exp,\n    not: not,\n    length: stringOrArrayLength,\n    '!': factorial,\n    sign: Math.sign || sign\n  };\n\n  this.binaryOps = {\n    '+': add,\n    '-': sub,\n    '*': mul,\n    '/': div,\n    '%': mod,\n    '^': Math.pow,\n    '||': concat,\n    '==': equal,\n    '!=': notEqual,\n    '>': greaterThan,\n    '<': lessThan,\n    '>=': greaterThanEqual,\n    '<=': lessThanEqual,\n    and: andOperator,\n    or: orOperator,\n    'in': inOperator,\n    '=': setVar,\n    '[': arrayIndex\n  };\n\n  this.ternaryOps = {\n    '?': condition\n  };\n\n  this.functions = {\n    random: random,\n    fac: factorial,\n    min: min,\n    max: max,\n    hypot: Math.hypot || hypot,\n    pyt: Math.hypot || hypot, // backward compat\n    pow: Math.pow,\n    atan2: Math.atan2,\n    'if': condition,\n    gamma: gamma,\n    roundTo: roundTo,\n    map: arrayMap,\n    fold: arrayFold,\n    filter: arrayFilter,\n    indexOf: stringOrArrayIndexOf,\n    join: arrayJoin\n  };\n\n  this.consts = {\n    E: Math.E,\n    PI: Math.PI,\n    'true': true,\n    'false': false\n  };\n}\n\nParser.prototype.parse = function (expr) {\n  var instr = [];\n  var parserState = new ParserState(\n    this,\n    new TokenStream(this, expr),\n    { allowMemberAccess: this.options.allowMemberAccess }\n  );\n\n  parserState.parseExpression(instr);\n  parserState.expect(TEOF, 'EOF');\n\n  return new Expression(instr, this);\n};\n\nParser.prototype.evaluate = function (expr, variables) {\n  return this.parse(expr).evaluate(variables);\n};\n\nvar sharedParser = new Parser();\n\nParser.parse = function (expr) {\n  return sharedParser.parse(expr);\n};\n\nParser.evaluate = function (expr, variables) {\n  return sharedParser.parse(expr).evaluate(variables);\n};\n\nvar optionNameMap = {\n  '+': 'add',\n  '-': 'subtract',\n  '*': 'multiply',\n  '/': 'divide',\n  '%': 'remainder',\n  '^': 'power',\n  '!': 'factorial',\n  '<': 'comparison',\n  '>': 'comparison',\n  '<=': 'comparison',\n  '>=': 'comparison',\n  '==': 'comparison',\n  '!=': 'comparison',\n  '||': 'concatenate',\n  'and': 'logical',\n  'or': 'logical',\n  'not': 'logical',\n  '?': 'conditional',\n  ':': 'conditional',\n  '=': 'assignment',\n  '[': 'array',\n  '()=': 'fndef'\n};\n\nfunction getOptionName(op) {\n  return optionNameMap.hasOwnProperty(op) ? optionNameMap[op] : op;\n}\n\nParser.prototype.isOperatorEnabled = function (op) {\n  var optionName = getOptionName(op);\n  var operators = this.options.operators || {};\n\n  return !(optionName in operators) || !!operators[optionName];\n};\n\n/*!\n Based on ndef.parser, by Raphael Graf(r@undefined.ch)\n http://www.undefined.ch/mparser/index.html\n\n Ported to JavaScript and modified by Matthew Crumley (email@matthewcrumley.com, http://silentmatt.com/)\n\n You are free to use and modify this code in anyway you find useful. Please leave this comment in the code\n to acknowledge its original source. If you feel like it, I enjoy hearing about projects that use my code,\n but don't feel like you have to let me know or ask permission.\n*/\n\n// Backwards compatibility\nvar index = {\n  Parser: Parser,\n  Expression: Expression\n};\n\nexport default index;\nexport { Expression, Parser };\n","import { parseFunction } from './functionParsing.js';\r\nimport { view } from './rendering.js';\r\nimport { roundValue } from './math.js';\r\n\r\nfunction calculateRoot(f, guess) {\r\n  let root = newtonsMethod(f, guess);\r\n  let expr = parseFunction(f);\r\n  if (Math.abs(expr.evaluate({x: root})) < Math.pow(10, -10)) {\r\n    return root;\r\n  } else {\r\n    return null;\r\n  }\r\n}\r\n\r\n// Calculate the intercections of two graphs, f and g, by calculating the root of f - g.\r\nfunction calculateIntersection(f1, f2, guess, depth = 100) {\r\n  let expr1 = parseFunction(f1);\r\n  let expr2 = parseFunction(f2);\r\n\r\n  if (depth == 0) {\r\n    if (Math.abs(expr1.evaluate({x: guess}) - expr2.evaluate({x: guess})) < Math.pow(10, -10)) {\r\n      return {x: guess, y: expr1.evaluate({x: guess})}\r\n    } else {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  let x = guess;\r\n  let y1 = expr1.evaluate({x});\r\n  let y2 = expr2.evaluate({x});\r\n  let y = y1 - y2;\r\n  let deltaX = Math.pow(10, -5);\r\n  let deltaY = expr1.evaluate({x: x + deltaX}) - expr2.evaluate({x: x + deltaX}) - y;\r\n  let derivative = deltaY/deltaX;\r\n  let nextGuess = x - y/derivative;\r\n  return calculateIntersection(f1, f2, nextGuess, depth - 1);\r\n}\r\n\r\n// Approximates the x-intercept of a function given a guess\r\nfunction newtonsMethod(f, guess, depth = 100) {\r\n  if (depth == 0) {\r\n    return guess;\r\n  }\r\n  let expr = parseFunction(f);\r\n  let x = guess;\r\n  let y = expr.evaluate({x});\r\n  let deltaX = Math.pow(10, -5);\r\n  let deltaY = expr.evaluate({x: x + deltaX}) - y;\r\n  let derivative = deltaY/deltaX;\r\n  let nextGuess = x - y/derivative;\r\n  return newtonsMethod(f, nextGuess, depth - 1);\r\n}\r\n\r\nfunction renderCalculateTab() {\r\n  let selects = document.querySelectorAll('.function-list');\r\n  let enteredFunction = false;\r\n  for (let i = 0; i < selects.length; i++) {\r\n    let selectElement = selects[i];\r\n    selectElement.innerHTML = '';\r\n    for (let key in view.functions) {\r\n      enteredFunction = true;\r\n      let optionElement = document.createElement('option');\r\n      let expression = view.functions[key].expression;\r\n      optionElement.value = expression;\r\n      optionElement.textContent = expression;\r\n      selectElement.appendChild(optionElement);\r\n    }\r\n  }\r\n  if (!enteredFunction) {\r\n    document.querySelector('.calculate-tab .warning').textContent = 'Please enter a function in the \"Functions\" tab.';\r\n  }\r\n  else {\r\n    document.querySelector('.calculate-tab .warning').textContent = '';\r\n  }\r\n}\r\n\r\nfunction addCalculateTabListeners() {\r\n  // Calculate root button\r\n  document.querySelector('.roots > button').addEventListener('click', function() {\r\n    let outputDiv = document.querySelector('.roots > .root-output');\r\n    let guess = parseFloat(document.querySelector('.roots > input[name=\"guess\"]').value);\r\n    let expression = document.querySelector('.roots > select[name=\"expression\"]').value;\r\n    let root = calculateRoot(expression, guess);\r\n    if (root != null) {\r\n      outputDiv.textContent = `Root: (${roundValue(root, 6)}, 0)`;\r\n    } else {\r\n      outputDiv.textContent = 'Root not found';\r\n    }\r\n  });\r\n\r\n  document.querySelector('.intersections > button').addEventListener('click', function() {\r\n    let outputDiv = document.querySelector('.intersections > .intersection-output');\r\n    let guess = parseFloat(document.querySelector('.intersections > input[name=\"guess\"]').value);\r\n    let expression1 = document.querySelector('.intersections > select[name=\"expression1\"]').value;\r\n    let expression2 = document.querySelector('.intersections > select[name=\"expression2\"]').value;\r\n    let intersection = calculateIntersection(expression1, expression2, guess);\r\n\r\n    if (intersection != null) {\r\n      outputDiv.textContent = `Intersection: (${roundValue(intersection.x, 6)}, ${roundValue(intersection.y, 6)})`;\r\n    } else {\r\n      outputDiv.textContent = 'Intersection not found or graphs are equivalent';\r\n    }\r\n  });\r\n}\r\n\r\nexport {addCalculateTabListeners, renderCalculateTab}\r\n","// Drawing module\r\nfunction Draw(canvas) {\r\n  this.canvas = canvas;\r\n  this.ctx = canvas.getContext('2d');\r\n}\r\n\r\nDraw.prototype.fill = function(color) {\r\n  this.canvas.fillStyle = color;\r\n}\r\n\r\nDraw.prototype.line = function(x1, y1, x2, y2, color = 'black') {\r\n  this.ctx.beginPath();\r\n  this.ctx.moveTo(x1, y1);\r\n  this.ctx.lineTo(x2, y2);\r\n  this.ctx.strokeStyle = color;\r\n  this.ctx.stroke();\r\n}\r\n\r\nDraw.prototype.text = function(string, x, y, size = 10 * canvas.scale) {\r\n  this.ctx.font = size + 'px Arial';\r\n  this.ctx.fillText(string, x, y);\r\n}\r\n\r\nDraw.prototype.rect = function(x, y, width, height, color = 'white') {\r\n  this.ctx.fillStyle = color;\r\n  this.ctx.fillRect(x, y, width, height);\r\n}\r\n\r\nDraw.prototype.colorCircle = function(centerX, centerY, radius, color = 'black') {\r\n  this.ctx.fillStyle = color;\r\n  this.ctx.beginPath();\r\n  this.ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);\r\n  this.ctx.fill();\r\n}\r\n\r\nexport { Draw }\r\n","import {canvas, ctx, draw, view, render, toPixelCoord} from './rendering.js'\r\nimport { parseFunction } from './functionParsing.js';\r\nimport {renderCalculateTab, addCalculateTabListeners} from './calculate.js';\r\n\r\nlet isDragging = false;\r\nlet numOfFunctions = 0;\r\nlet draggedPoint;\r\n\r\nfunction mousePos(e) {\r\n  let rect = canvas.getBoundingClientRect();\r\n  return {\r\n    x: (e.clientX - rect.left) * canvas.width/(rect.right - rect.left),\r\n    y: (e.clientY - rect.top) * canvas.height/(rect.bottom - rect.top)\r\n  };\r\n}\r\n\r\n// px to units\r\nfunction toUnitCoord(x, y) {\r\n  let graphWidth = view.xMax - view.xMin;\r\n  let graphHeight = view.yMax - view.yMin;\r\n  return {\r\n    x: view.xMin + (x/(canvas.width)) * graphWidth,\r\n    y: view.yMax - (y/(canvas.height)) * graphHeight\r\n  };\r\n}\r\n\r\nfunction addFunction() {\r\n  numOfFunctions++;\r\n  let functionName = 'y' + numOfFunctions;\r\n  let functionTemplate = document.getElementById('function-template').cloneNode(true);\r\n\r\n  let input = functionTemplate.querySelector('input');\r\n  let select = functionTemplate.querySelector('select');\r\n  let colors = [];\r\n\r\n  // Creates an array of the possible colors\r\n  for (let i = 0, options = select.children; i < options.length; i++) {\r\n    colors.push(options[i].value);\r\n  }\r\n  // Make sure the function starts with a different color\r\n  let functionColor = colors[(numOfFunctions - 1) % colors.length];\r\n\r\n  functionTemplate.removeAttribute('id')\r\n  functionTemplate.classList.add(functionName);\r\n  // Add attributes\r\n  input.name = functionName;\r\n  input.placeholder = functionName;\r\n  select.name = functionName;\r\n  select.value = functionColor;\r\n\r\n  // Insert the function before the button\r\n  // document.querySelector('.functions').insertBefore(functionTemplate, document.querySelector('button'));\r\n  document.querySelector('.functions').appendChild(functionTemplate);\r\n  // Whenever the input is updated, update the graph\r\n  let event1 = input.addEventListener('input', graphFunctions);\r\n  let event2 = select.addEventListener('change', graphFunctions);\r\n  let event3 = functionTemplate.querySelector('.delete').addEventListener('click', function() {\r\n    functionTemplate.removeEventListener('input', event1);\r\n    functionTemplate.removeEventListener('change', event2);\r\n    functionTemplate.removeEventListener('click', event3);\r\n    functionTemplate.innerHTML = '';\r\n    graphFunctions();\r\n  });\r\n}\r\n\r\naddFunction();\r\n\r\n// Retrieve all inputs from the DOM, and add it to the view variable\r\nfunction graphFunctions() {\r\n  for (let i = 1; i <= numOfFunctions; i++) {\r\n    let functionName = 'y' + i;\r\n    let functionInput = document.querySelector(`.functions input[name=\"${functionName}\"]`);\r\n    if (functionInput) {\r\n      let functionObject = view.functions[functionName] = {};\r\n      functionObject.expression = functionInput.value;\r\n      functionObject.color = document.querySelector(`.functions select[name=\"${functionName}\"]`).value;\r\n    } else {\r\n      delete view.functions[functionName];\r\n    }\r\n  }\r\n  render();\r\n}\r\n\r\n// Render calculator options tab (graph, table, calculate)\r\nfunction renderTab(tabName) {\r\n  let tabList = ['function', 'table', 'calculate'];\r\n  for (let i = 0; i < tabList.length; i++) {\r\n    try {\r\n      document.querySelector(`.${tabList[i]}-nav`).style.backgroundColor = 'whitesmoke';\r\n      document.querySelector(`.${tabList[i]}-tab`).style.display = 'none';\r\n    } catch(e) {\r\n      console.log(`Tab not found: ${tabList[i]}.`);\r\n    }\r\n  }\r\n  if (tabName == 'calculate') {\r\n    renderCalculateTab();\r\n  }\r\n  document.querySelector(`.${tabName}-nav`).style.backgroundColor = 'lightgray';\r\n  document.querySelector(`.${tabName}-tab`).style.display = '';\r\n}\r\n\r\n// Render tabs in the navbar\r\nfunction renderNavBarTab(tabName) {\r\n  let tabList = ['home', 'about'];\r\n  for (let i = 0; i < tabList.length; i++) {\r\n    let tab = tabList[i];\r\n    let tabDiv = document.querySelector('.' + tab + '-page');\r\n    let tabLinkDiv = document.getElementById(tab)\r\n    if (tab == tabName) {\r\n      tabDiv.style.display = '';\r\n      tabLinkDiv.style.fontWeight = 'bold';\r\n    } else {\r\n      tabDiv.style.display = 'none';\r\n      tabLinkDiv.style.fontWeight = 'normal';\r\n    }\r\n  }\r\n}\r\n\r\nrenderNavBarTab('home');\r\n\r\nfunction addCanvasListeners() {\r\n  canvas.addEventListener('mousedown', function(e) {\r\n    draggedPoint = mousePos(e);\r\n    isDragging = true;\r\n    let currentPos = mousePos(e);\r\n    render();\r\n  });\r\n\r\n  document.addEventListener('mouseup', function() {\r\n    isDragging = false;\r\n  });\r\n\r\n  // Handles dragging; moves window opposite of dragged direction\r\n  canvas.addEventListener('mousemove', function(e) {\r\n    if (isDragging) {\r\n\r\n      let currentPos = mousePos(e);\r\n      let xDiff = toUnitCoord(currentPos.x, 0).x - toUnitCoord(draggedPoint.x, 0).x;\r\n      let yDiff = toUnitCoord(0, currentPos.y).y - toUnitCoord(0, draggedPoint.y).y;\r\n\r\n      view.xMin -= xDiff;\r\n      view.xMax -= xDiff;\r\n      view.yMin -= yDiff;\r\n      view.yMax -= yDiff;\r\n\r\n      draggedPoint = currentPos;\r\n      render();\r\n    }\r\n  });\r\n\r\n  // Zooming in and out\r\n  canvas.addEventListener('wheel', function(e) {\r\n    e.preventDefault();\r\n    let currentPos = mousePos(e);\r\n    let gridPos = toUnitCoord(currentPos.x, currentPos.y);\r\n\r\n    let distFromLeft = gridPos.x - view.xMin;\r\n    let distFromRight = view.xMax - gridPos.x;\r\n    let distFromTop = view.yMax - gridPos.y;\r\n    let distFromBottom = gridPos.y - view.yMin;\r\n    let factor = 0.05;\r\n    // zoom out\r\n    if (e.deltaY > 0) {\r\n      view.xMin -= distFromLeft * factor;\r\n      view.xMax += distFromRight * factor;\r\n      view.yMin -= distFromBottom * factor;\r\n      view.yMax += distFromTop * factor;\r\n    }\r\n    // zoom in\r\n    else if (e.deltaY < 0) {\r\n      view.xMin += distFromLeft * factor;\r\n      view.xMax -= distFromRight * factor;\r\n      view.yMin += distFromBottom * factor;\r\n      view.yMax -= distFromTop * factor;\r\n    }\r\n    render();\r\n  });\r\n\r\n  // Trace functionality; show the point on a graph closest to the cursor\r\n  canvas.addEventListener('mousemove', function(e) {\r\n    let mousePosX = toUnitCoord(mousePos(e).x, 0).x;\r\n    let mousePosY = toUnitCoord(0, mousePos(e).y).y;\r\n    let pointY;\r\n    let pointColor;\r\n    for (let key in view.functions) {\r\n      let expr = parseFunction(view.functions[key].expression);\r\n      let y = expr.evaluate({x: mousePosX});\r\n      if (y > view.yMin && y < view.yMax && Math.abs(mousePos(e).y - toPixelCoord(0, y).y) < 50) {\r\n        if (!pointY || Math.abs(y - mousePosY) < Math.abs(pointY - mousePosY)) {\r\n          pointY = y\r\n          pointColor = view.functions[key].color;\r\n        }\r\n      }\r\n    }\r\n    // Draw point\r\n    if (pointY && pointColor) {\r\n      view.point.x = mousePosX;\r\n      view.point.y = pointY;\r\n      view.point.color = pointColor;\r\n    } else {\r\n      view.point = {};\r\n    }\r\n    render();\r\n  });\r\n\r\n  canvas.onmouseout = function() {\r\n    view.point = {};\r\n    render();\r\n  }\r\n}\r\n\r\nfunction eventHandling() {\r\n  addCanvasListeners()\r\n\r\n  // \"Add Function\" button\r\n  document.querySelector('button[class=\"add-function\"]').addEventListener('click', function() {\r\n    addFunction();\r\n  });\r\n\r\n  // event listeners for the window\r\n  let windowElements = ['x-min', 'x-max', 'y-min', 'y-max', 'x-scale', 'y-scale'];\r\n  for (let i = 0; i < windowElements.length; i++) {\r\n    document.querySelector(`input[name=\"${windowElements[i]}\"]`).addEventListener('input', function() {\r\n      let xMin = document.querySelector('input[name=\"x-min\"]').value;\r\n      let xMax = document.querySelector('input[name=\"x-max\"]').value;\r\n      let xScale = parseFloat(document.querySelector('input[name=\"x-scale\"]').value);\r\n      let yMin = document.querySelector('input[name=\"y-min\"]').value;\r\n      let yMax = document.querySelector('input[name=\"y-max\"]').value;\r\n      let yScale = parseFloat(document.querySelector('input[name=\"y-scale\"]').value);\r\n\r\n      if (xMin && xMax && parseFloat(xMin) < parseFloat(xMax)) {\r\n        view.xMax = parseFloat(xMax);\r\n        view.xMin = parseFloat(xMin);\r\n      }\r\n\r\n      if (yMin && yMax && parseFloat(yMin) < parseFloat(yMax)) {\r\n        view.yMax = parseFloat(yMax);\r\n        view.yMin = parseFloat(yMin);\r\n      }\r\n\r\n      if (xScale && xScale > 0) {\r\n        view.xScale = xScale;\r\n      } else {\r\n        view.xScale = 4;\r\n      }\r\n      if (yScale && yScale > 0) {\r\n        view.yScale = yScale;\r\n      } else {\r\n        view.yScale = 4;\r\n      }\r\n      render();\r\n    });\r\n  }\r\n\r\n  document.querySelector('button[class=\"clear-window\"]').addEventListener('click', function() {\r\n    for (let i = 0; i < windowElements.length; i++) {\r\n      document.querySelector(`input[name=\"${windowElements[i]}\"]`).value = '';\r\n    }\r\n  });\r\n\r\n  document.querySelector('button[class=\"reset-window\"]').addEventListener('click', function() {\r\n    view.xMin = -22.5;\r\n    view.xMax = 22.5;\r\n    view.yMin = -22.5;\r\n    view.yMax = 22.5;\r\n    view.xScale = 4;\r\n    view.yScale = 4;\r\n    render();\r\n  });\r\n\r\n  // render tabs\r\n  let tabList = ['function', 'table', 'calculate'];\r\n  for (let i = 0; i < tabList.length; i++) {\r\n    document.querySelector(`.${tabList[i]}-nav`).addEventListener('click', function() {\r\n      renderTab(tabList[i]);\r\n    });\r\n  }\r\n  addCalculateTabListeners();\r\n\r\n  let tabListNav = ['home', 'about'];\r\n  for (let i = 0; i < tabListNav.length; i++) {\r\n    document.querySelector(`#${tabListNav[i]}`).addEventListener('click', function() {\r\n      renderNavBarTab(tabListNav[i]);\r\n    });\r\n  }\r\n}\r\n\r\nexport { eventHandling, renderTab };\r\n","// https://github.com/silentmatt/expr-eval/tree/master\r\nlet Parser = require('expr-eval').Parser;\r\n\r\nvar parser = new Parser();\r\n\r\nString.prototype.add = function(index, string) {\r\n  return this.slice(0, index) + string + this.slice(index);\r\n}\r\n\r\nfunction parseFunction(expression) {\r\n  expression = expression.split(' ').join('');\r\n  expression = logify(expression);\r\n  expression = addMultiplySymbols(expression);\r\n  return parser.parse(expression);\r\n}\r\n\r\n// Add a multiplication symbol if it is ommited\r\n// e.g: '3x' -> '3*x', '(x+1)(x+2)' -> '(x+1)*(x+2)'\r\nfunction addMultiplySymbols(expression) {\r\n  for (let i = 0; i < expression.length; i++) {\r\n    /* A multiplication symbol is added if a:\r\n    - number comes before a variable or opening bracket\r\n    - closing bracket or number comes before an opening bracket\r\n    */\r\n    if ((!isNaN(expression[i]) || [')', 'x'].includes(expression[i]))  && (expression[i + 1] == '(' || expression[i + 1] && /[a-z]/.test(expression[i + 1]))) {\r\n      expression = expression.add(i + 1, '*');\r\n    }\r\n  }\r\n  return expression;\r\n}\r\n\r\n// Allow logs with any base\r\n// e.g 'log3(x)' -> 'ln(x)/ln(3)'\r\nfunction logify(expression) {\r\n  // let log(x) be equivalent to log10(x)\r\n  expression = expression.replace(/log\\(/g, 'log10(')\r\n\r\n  let logRegex = /log\\d+\\([^)]+\\)/;\r\n  let logExpressions = expression.match(logRegex);\r\n  while (logExpressions) {\r\n    for (let i = 0; i < logExpressions.length; i++) {\r\n      logExpressions[i] = fixBrackets(logExpressions[i]);\r\n      let logBase = /log(\\d+)\\([^)]+\\)/.exec(logExpressions[i])[1];\r\n      let logArg = fixBrackets(/log\\d+\\(([^)]+)\\)/.exec(logExpressions[i])[1]);\r\n      let oldExpression = expression;\r\n      expression = expression.replace(logExpressions[i], `(ln(${logArg})/ln(${logBase}))`);\r\n      if (oldExpression == expression) {\r\n        return expression;\r\n      }\r\n    }\r\n    logExpressions = expression.match(logRegex);\r\n  }\r\n  return expression;\r\n}\r\n\r\n// Fixes inequality between opening and closing brackets\r\n// e.g 'sin(x))' -> '(sin(x))', 'sin(x' -> 'sin(x)'\r\nfunction fixBrackets(expression) {\r\n  let openingBrackets = 0;\r\n  let closingBrackets = 0;\r\n  for (let i = 0; i < expression.length; i++) {\r\n    if (expression[i] == '(') {\r\n      openingBrackets++;\r\n    } else if (expression[i] == ')') {\r\n      closingBrackets++;\r\n    }\r\n  }\r\n  while (openingBrackets > closingBrackets) {\r\n    expression += ')'\r\n    closingBrackets++;\r\n  }\r\n  while (closingBrackets > openingBrackets) {\r\n    expression = '(' + expression;\r\n    openingBrackets++;\r\n  }\r\n  return expression;\r\n}\r\n\r\nexport { parseFunction }\r\n","import { render, canvas } from './rendering.js';\r\nimport {eventHandling, renderTab} from './eventHandling.js';\r\n\r\nrenderTab('function');\r\nrender();\r\neventHandling();\r\n","function roundValue(number, precision = 3) {\r\n  if (Math.abs(number) == Infinity || number == NaN) {\r\n    return '';\r\n  }\r\n  if (number == 0) {\r\n    return 0;\r\n  }\r\n  if (Math.abs(number) <= 0.0001) {\r\n    return parseFloat((number).toPrecision(precision)).toExponential().replace('e', '*10^');\r\n  }\r\n  if (Math.abs(number) >= 100000) {\r\n    return number.toPrecision(precision).replace('e+', '*10^');\r\n  }\r\n  if (Math.abs(number) < 100000) {\r\n    return parseFloat((number).toPrecision(precision));\r\n  }\r\n}\r\n\r\nexport {roundValue}\r\n","// Problem: computers with bigger monitors\r\nimport { Draw } from './drawing.js';\r\nimport { parseFunction } from './functionParsing.js';\r\nimport { renderTable } from './table.js';\r\n\r\nlet canvas = document.getElementById('canvas');\r\nlet ctx = canvas.getContext('2d');\r\n\r\n// Increase canvas resolution\r\ncanvas.scale = 2;\r\ncanvas.width *= canvas.scale;\r\ncanvas.height *= canvas.scale;\r\n\r\nlet draw = new Draw(canvas);\r\nlet view = {\r\n  xScale: 4,\r\n  yScale: 4,\r\n  xMin: -22.5,\r\n  xMax: 22.5,\r\n  yMin: -22.5,\r\n  yMax: 22.5,\r\n  functions: {},\r\n  point: {}\r\n}\r\nlet expression = '';\r\n\r\n// Units to px\r\nfunction toPixelCoord(x, y) {\r\n  let pixelX = (x - view.xMin)/(view.xMax - view.xMin) * canvas.width;\r\n  let pixelY = (view.yMax - y)/(view.yMax - view.yMin) * canvas.width;\r\n  return {x: pixelX, y: pixelY};\r\n}\r\n\r\n// Round scale to one or two significant digits\r\nfunction roundScale(scale) {\r\n  if (scale >= 1 && scale <= 9) {\r\n    return parseFloat((scale).toPrecision(1));\r\n  } else {\r\n    return parseFloat((scale).toPrecision(2));\r\n  }\r\n}\r\n\r\nfunction roundTickMark(number) {\r\n  if (number == 0) {\r\n    return 0;\r\n  }\r\n  if (Math.abs(number) <= 0.0001) {\r\n    return parseFloat((number).toPrecision(3)).toExponential().replace('e', '*10^');\r\n  }\r\n  if (Math.abs(number) < 100000) {\r\n    return parseFloat((number).toPrecision(4));\r\n  }\r\n  if (Math.abs(number) >= 100000) {\r\n    return number.toPrecision(2).replace('e+', '*10^');\r\n  }\r\n}\r\n\r\n\r\n// Find a scale with about 10 tick marks on x and y axis\r\nfunction findAutoScale() {\r\n  let xScale = view.xScale;\r\n  let yScale = view.yScale;\r\n\r\n  if ((view.xMax <= view.xMin) || (view.yMax <= view.yMin) || (view.xScale <= 0) || (view.yScale <= 0)) {\r\n    console.log('Error: invalid window settings');\r\n    xScale = 4;\r\n    yScale = 4;\r\n  }\r\n  if (Math.abs(view.xScale) == Infinity) {\r\n    xScale = 4;\r\n  } else if (Math.abs(view.yScale) == Infinity) {\r\n    yScale = 4;\r\n  }\r\n\r\n  let windowLength = (view.xMax - view.xMin)/xScale;\r\n  let windowHeight = (view.yMax - view.yMin)/yScale;\r\n\r\n  while (windowLength > 12) {\r\n    xScale *= 2;\r\n    windowLength = (view.xMax - view.xMin)/xScale;\r\n  }\r\n  while (windowLength < 4) {\r\n    xScale /= 2;\r\n    windowLength = (view.xMax - view.xMin)/xScale;\r\n  }\r\n  while (windowHeight > 12) {\r\n    yScale *= 2;\r\n    windowHeight = (view.yMax - view.yMin)/yScale;\r\n  }\r\n  while (windowHeight < 4) {\r\n    yScale /= 2;\r\n    windowHeight = (view.yMax - view.yMin)/yScale;\r\n  }\r\n  return {xScale, yScale};\r\n}\r\n\r\nfunction drawGridLines() {\r\n  ctx.lineWidth = canvas.scale;\r\n  let xTickRange = {\r\n    min: Math.ceil(view.xMin/view.xScale),\r\n    max: Math.floor(view.xMax/view.xScale)\r\n  }\r\n  let yTickRange = {\r\n    min: Math.ceil(view.yMin/view.yScale),\r\n    max: Math.floor(view.yMax/view.yScale)\r\n  }\r\n  for (let i = xTickRange.min; i <= xTickRange.max; i++) {\r\n    if (i == 0) continue;\r\n    let xDraw = toPixelCoord(i * view.xScale, 0).x\r\n    let yDraw = toPixelCoord(0, 0).y;\r\n    draw.line(xDraw, 0, xDraw, canvas.height, 'lightgray');\r\n  }\r\n  for (let i = yTickRange.min; i <= yTickRange.max; i++) {\r\n    if (i == 0) continue;\r\n    let xDraw = toPixelCoord(0, 0).x\r\n    let yDraw = toPixelCoord(0, i * view.yScale).y;\r\n    draw.line(0, yDraw, canvas.width, yDraw, 'lightgray');\r\n  }\r\n}\r\n\r\n// Draws axes\r\nfunction drawAxes() {\r\n  ctx.fillStyle = 'black';\r\n  ctx.lineWidth = 1.5 * canvas.scale;\r\n  // y axis\r\n  draw.line(0, toPixelCoord(0, 0).y, canvas.width, toPixelCoord(0, 0).y);\r\n  // x axis\r\n  draw.line(toPixelCoord(0, 0).x, 0, toPixelCoord(0, 0).x, canvas.height);\r\n\r\n  // ticks on x axis\r\n  ctx.textBaseline = 'middle';\r\n  // ex: min: -2, max: 3, signifies 2 ticks right of x axis, and 3 ticks left\r\n  let xTickRange = {\r\n    min: Math.ceil(view.xMin/view.xScale),\r\n    max: Math.floor(view.xMax/view.xScale)\r\n  }\r\n\r\n  for (let i = xTickRange.min; i <= xTickRange.max; i++) {\r\n    ctx.textAlign = 'center';\r\n\r\n    if (i == 0) continue;\r\n    let xDisplayValue = roundTickMark(i * view.xScale);\r\n    let xDraw = toPixelCoord(i * view.xScale, 0).x\r\n    let yDraw = toPixelCoord(0, 0).y;\r\n    // ticks and labels\r\n    draw.line(xDraw, yDraw + 5 * canvas.scale, xDraw, yDraw - 5 * canvas.scale);\r\n    draw.text(xDisplayValue, xDraw, yDraw + 15 * canvas.scale);\r\n  }\r\n\r\n  // ticks on y axis\r\n  // ex: min: -2, max: 3, signifies 2 ticks above y axis, and 3 ticks below\r\n  let yTickRange = {\r\n    min: Math.ceil(view.yMin/view.yScale),\r\n    max: Math.floor(view.yMax/view.yScale)\r\n  }\r\n\r\n  for (let i = yTickRange.min; i <= yTickRange.max; i++) {\r\n    if (i == 0) continue;\r\n    ctx.textAlign = 'end';\r\n\r\n    let yDisplayValue = roundTickMark(i * view.yScale);\r\n    let xDraw = toPixelCoord(0, 0).x\r\n    let yDraw = toPixelCoord(0, i * view.yScale).y;\r\n    // ticks and labels\r\n    draw.line(xDraw - 5 * canvas.scale, yDraw, xDraw + 5 * canvas.scale, yDraw);\r\n    draw.text(yDisplayValue, xDraw - 10 * canvas.scale, yDraw);\r\n  }\r\n}\r\n\r\n\r\nfunction drawGraph(expr, color = 'black') {\r\n  let precision = 500;\r\n  let previousDerivative = 0;\r\n  let previousX = 0;\r\n  for (let i = 0; i < precision; i++) {\r\n    let currentX = view.xMin + i/precision * (view.xMax - view.xMin);\r\n    let nextX = view.xMin + (i + 1) * (view.xMax - view.xMin)/precision;\r\n    let currentY = expr.evaluate({ x: currentX });\r\n    let nextY = expr.evaluate({ x: nextX });\r\n\r\n    if (!currentY && !nextY) {\r\n      continue;\r\n    }\r\n\r\n    // When the derivative of the graph changes from positive to negative, assume that it's trying to graph an asymptote\r\n    let currentDerivative = (nextY - currentY)/(nextX - currentX);\r\n    if (currentDerivative * previousDerivative >= 0) {\r\n      draw.line(toPixelCoord(currentX, 0).x, toPixelCoord(0, currentY).y, toPixelCoord(nextX, 0).x, toPixelCoord(0, nextY).y, color);\r\n    // Graphs more precisely around asymptotes. Fixes issue where lines that approach asymptotes suddenly cut off\r\n    } else {\r\n      // If curve approaches asymptote from left side\r\n      if (Math.abs(previousDerivative) < Math.abs(currentDerivative) || !currentDerivative) {\r\n        graphAroundAsymptote(expr, currentX, nextX, previousDerivative, 20, color);\r\n      // If curve approaches asymptote from right side\r\n      } else {\r\n        graphAroundAsymptote(expr, nextX, previousX, currentDerivative, 20, color);\r\n      }\r\n      draw.line(toPixelCoord(currentX, 0).x, toPixelCoord(0, currentY).y, toPixelCoord(nextX, 0).x, toPixelCoord(0, currentY).y, color);\r\n    }\r\n    previousDerivative = currentDerivative;\r\n    previousX = currentX;\r\n  }\r\n}\r\n\r\nfunction drawPoint(x, y, color) {\r\n  let pointX = toPixelCoord(x, 0).x;\r\n  let pointY = toPixelCoord(0, y).y;\r\n  draw.colorCircle(pointX, pointY, 5, color);\r\n  ctx.textAlign = 'left';\r\n  draw.text(`(${roundTickMark(x)}, ${roundTickMark(y)})`, pointX + 10, pointY + 15)\r\n}\r\n\r\n// graphAroundAsymptote recursively graphs more accurately around asymptotes. It fixes the issue where the curve that approaches asymptotes suddenly cut off\r\nfunction graphAroundAsymptote(expr, aX1, aX2, previousDerivative, depth, color) {\r\n  let precision = 2;\r\n  for (let j = 0; j < precision; j++) {\r\n    let currentX = aX1 + (aX2 - aX1) * j/precision;\r\n    let nextX = aX1 + (aX2 - aX1) * (j + 1)/precision;\r\n    let currentY = expr.evaluate({ x: currentX });\r\n    let nextY = expr.evaluate({ x: nextX });\r\n    let currentDerivative = (nextY - currentY)/(nextX - currentX);\r\n    // Makes ure that when it is graphing around asymptotes, it doesn't accidently connect points through an asymptote\r\n    if (currentDerivative * previousDerivative >= 0) {\r\n      draw.line(toPixelCoord(currentX, 0).x, toPixelCoord(0, currentY).y, toPixelCoord(nextX, 0).x, toPixelCoord(0, nextY).y, color);\r\n    } else {\r\n      if (depth > 1) {\r\n        graphAroundAsymptote(expr, currentX, nextX, previousDerivative, depth - 1, color);\r\n      }\r\n      return;\r\n    }\r\n    previousDerivative = currentDerivative;\r\n  }\r\n}\r\n\r\nfunction render() {\r\n  let autoScale = findAutoScale();\r\n  view.xScale = autoScale.xScale;\r\n  view.yScale = autoScale.yScale;\r\n  draw.rect(0, 0, canvas.width, canvas.height);\r\n  drawGridLines();\r\n  drawAxes();\r\n  for (let key in view.functions) {\r\n    if (!view.functions[key].expression) {\r\n      delete view.functions[key];\r\n      continue;\r\n    }\r\n    try {\r\n      drawGraph(parseFunction(view.functions[key].expression), view.functions[key].color);\r\n    } catch(e) {\r\n      console.log(view.functions[key].expression + ' is not a valid function.')\r\n    }\r\n  }\r\n  // Draws point on graph closest to cursor\r\n  drawPoint(view.point.x, view.point.y, view.point.color);\r\n  renderTable();\r\n}\r\n\r\nexport {canvas, ctx, draw, render, view, toPixelCoord, findAutoScale }\r\n","import { view } from './rendering.js';\r\nimport { parseFunction } from './functionParsing.js';\r\nimport { roundValue } from './math.js';\r\n\r\nfunction renderTable() {\r\n  let tableElement = document.querySelector('table');\r\n\r\n  // table headers / labels\r\n  tableElement.innerHTML = '';\r\n  let headerRow = document.createElement('tr');\r\n  let xLabel = document.createElement('th');\r\n  xLabel.textContent = 'x';\r\n  headerRow.appendChild(xLabel);\r\n\r\n  // values of tables\r\n  for (let key in view.functions) {\r\n    let tableHeader = document.createElement('th');\r\n    tableHeader.textContent = key;\r\n    headerRow.appendChild(tableHeader);\r\n  }\r\n  tableElement.appendChild(headerRow);\r\n\r\n  let tblMin = Math.ceil(view.xMin/view.xScale) * view.xScale;\r\n  let tblMax = Math.floor(view.xMax/view.xScale) * view.xScale;\r\n  let numberOfValues = (tblMax - tblMin)/view.xScale;\r\n\r\n  for (let i = 0; i <= numberOfValues; i++) {\r\n    let x = tblMin + (tblMax - tblMin) * i/numberOfValues;\r\n    let tableRow = document.createElement('tr');\r\n    let xColumn = document.createElement('td');\r\n    xColumn.textContent = roundValue(x);\r\n    tableRow.appendChild(xColumn);\r\n\r\n    for (let key in view.functions) {\r\n      let yColumn = document.createElement('td');\r\n      let expr = parseFunction(view.functions[key].expression);\r\n      if (!expr) {\r\n        continue\r\n      }\r\n      yColumn.textContent = roundValue(expr.evaluate({x}));\r\n\r\n      tableRow.appendChild(yColumn);\r\n    }\r\n    tableElement.appendChild(tableRow);\r\n  }\r\n}\r\n\r\nexport { renderTable };\r\n"],"sourceRoot":""}